<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>스타포스 비용 계산기</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Malgun Gothic', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .setting-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #e9ecef;
        }
        
        .setting-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #495057;
        }
        
        .setting-group input, .setting-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        .setting-group input:focus, .setting-group select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .checkbox-group label {
            margin: 0;
            cursor: pointer;
        }
        
        .btn-calculate {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-bottom: 30px;
        }
        
        .btn-calculate:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }
        
        .btn-calculate:active {
            transform: translateY(0);
        }
        
        .results {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 30px;
            border-left: 5px solid #667eea;
        }
        
        .results h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        
        .result-item {
            padding: 12px;
            background: white;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .result-label {
            font-weight: bold;
            color: #495057;
        }
        
        .result-value {
            color: #667eea;
            font-weight: bold;
            font-size: 1.1em;
        }
        
        #chartContainer {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-top: 30px;
        }
        
        .percentile-calculator {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            border: 2px solid #667eea;
        }
        
        .percentile-calculator h3 {
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .calculator-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid #dee2e6;
        }
        
        .calculator-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .percentile-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .percentile-input-group input {
            flex: 1;
            min-width: 150px;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 16px;
        }
        
        .percentile-input-group button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .percentile-input-group button:hover {
            background: #5568d3;
        }
        
        .percentile-result {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: bold;
            color: #667eea;
        }
        
        .cost-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .cost-input-wrapper {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .cost-input-wrapper input {
            width: 80px;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 16px;
        }
        
        .cost-input-wrapper span {
            font-weight: bold;
            color: #495057;
        }
        
        canvas {
            max-height: 400px;
        }
        
        .hidden {
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>⭐ 스타포스 비용 계산기</h1>
        
        <div class="settings-grid">
            <div class="setting-group">
                <label>목표 스타 ★</label>
                <input type="number" id="targetStar" value="30" min="1" max="30">
            </div>
            
            <div class="setting-group">
                <label>시작 스타 ★</label>
                <input type="number" id="startStar" value="0" min="0" max="29">
            </div>
            
            <div class="setting-group">
                <label>아이템 레벨</label>
                <input type="number" id="itemLevel" value="250" min="1" max="300">
            </div>
            
            <div class="setting-group">
                <label>스페어 장비 비용</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="number" id="spareEok" value="16" min="0" placeholder="억" style="flex: 1;">
                    <span style="font-weight: bold;">억</span>
                    <input type="number" id="spareMan" value="0" min="0" max="9999" placeholder="만" style="flex: 1;">
                    <span style="font-weight: bold;">만 메소</span>
                </div>
            </div>
            
            <div class="setting-group">
                <label>MVP 등급</label>
                <select id="mvpLevel">
                    <option value="0">없음</option>
                    <option value="1">실버</option>
                    <option value="2">골드</option>
                    <option value="3" selected>다이아</option>
                </select>
            </div>
        </div>
        
        <div class="settings-grid">
            <div class="setting-group">
                <div class="checkbox-group">
                    <input type="checkbox" id="catch" checked>
                    <label for="catch">스타캐치 (5% 성공률 증가)</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="sundayM" checked>
                    <label for="sundayM">30% 할인 (비용 감소)</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="sundayD" checked>
                    <label for="sundayD">파방 이벤트 (파괴율 감소)</label>
                </div>
            </div>
            
            <div class="setting-group">
                <div class="checkbox-group">
                    <input type="checkbox" id="protect" checked>
                    <label for="protect">15~17성 보호</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="pcbang" checked>
                    <label for="pcbang">PC방 (5% 할인)</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="sundayOpO">
                    <label for="sundayOpO">1+1 이벤트</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="sundayFive">
                    <label for="sundayFive">5/10/15성 100% 성공</label>
                </div>
            </div>
        </div>
        
        <button class="btn-calculate" onclick="calculate()">계산하기</button>
        
        <div id="loadingDiv" class="loading hidden">계산 중...</div>
        
        <div id="resultsDiv" class="results hidden">
            <h2>📊 계산 결과</h2>
            <div id="resultsContent"></div>
        </div>
        
        <div id="chartContainer" class="hidden">
            <canvas id="distributionChart"></canvas>
            
            <div class="percentile-calculator">
                <div class="calculator-section">
                    <h3>🎯 분위수 → 비용 계산</h3>
                    <div class="percentile-input-group">
                        <input type="number" id="customPercentile" placeholder="분위수 입력 (0-100)" min="0" max="100" step="0.1" value="90">
                        <button onclick="calculateCustomPercentile()">계산</button>
                    </div>
                    <div id="customPercentileResult" class="percentile-result hidden"></div>
                </div>
                
                <div class="calculator-section">
                    <h3>💰 비용 → 분위수 계산</h3>
                    <div class="cost-input-group">
                        <div class="cost-input-wrapper">
                            <input type="number" id="costGyeong" placeholder="경" min="0" value="0">
                            <span>경</span>
                        </div>
                        <div class="cost-input-wrapper">
                            <input type="number" id="costJo" placeholder="조" min="0" max="9999" value="0">
                            <span>조</span>
                        </div>
                        <div class="cost-input-wrapper">
                            <input type="number" id="costEok" placeholder="억" min="0" max="9999" value="0">
                            <span>억</span>
                        </div>
                        <div class="cost-input-wrapper">
                            <input type="number" id="costMan" placeholder="만" min="0" max="9999" value="0">
                            <span>만</span>
                        </div>
                        <div class="cost-input-wrapper">
                            <input type="number" id="costWon" placeholder="메소" min="0" max="9999" value="0">
                            <span>메소</span>
                        </div>
                        <button onclick="calculateCostPercentile()">계산</button>
                    </div>
                    <div id="costPercentileResult" class="percentile-result hidden"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const MVP_DISCOUNTS = {0: 0.0, 1: 0.03, 2: 0.05, 3: 0.10};
        const PCBANG_DISCOUNT = 0.05;
        
        let currentAlpha, currentBeta;
        
        function initializeProbTable(catch_, sundayD, protect, sundayFive) {
            const Sp = Array(30).fill(0).map(() => [0, 0, 0]);
            const baseValues = [
                [0.95, 0.05, 0], [0.9, 0.1, 0], [0.85, 0.15, 0], [0.85, 0.15, 0], [0.8, 0.2, 0], [0.75, 0.25, 0],
                [0.70, 0.3, 0], [0.65, 0.35, 0], [0.60, 0.4, 0], [0.55, 0.45, 0], [0.50, 0.5, 0],
                [0.45, 0.55, 0], [0.40, 0.6, 0], [0.35, 0.65, 0], [0.30, 0.7, 0],
                [0.30, 0.679, 0.021], [0.30, 0.679, 0.021], [0.15, 0.782, 0.068], [0.15, 0.782, 0.068], [0.15, 0.765, 0.085],
                [0.30, 0.595, 0.105], [0.15, 0.7225, 0.1275], [0.15, 0.680, 0.17], [0.10, 0.720, 0.18], [0.10, 0.720, 0.18],
                [0.10, 0.720, 0.18], [0.07, 0.744, 0.186], [0.05, 0.760, 0.190], [0.03, 0.776, 0.194], [0.01, 0.792, 0.198]
            ];
            
            for (let i = 0; i < 30; i++) {
                Sp[i] = [...baseValues[i]];
            }
            
            if (sundayD) {
                for (let i = 0; i < 22; i++) {
                    Sp[i][1] += 0.3 * Sp[i][2];
                    Sp[i][2] *= 0.7;
                }
            }
            
            if (protect) {
                for (let i = 15; i < 18; i++) {
                    Sp[i][1] += Sp[i][2];
                    Sp[i][2] = 0;
                }
            }
            
            if (catch_) {
                for (let i = 0; i < 30; i++) {
                    const succ = Sp[i][0];
                    const fail = Sp[i][1];
                    const destroy = Sp[i][2];
                    const totalFail = fail + destroy;
                    if (totalFail > 0) {
                        Sp[i][0] = succ * 1.05;
                        Sp[i][1] = fail - 0.05 * succ * fail / totalFail;
                        Sp[i][2] = destroy - 0.05 * succ * destroy / totalFail;
                    }
                }
            }
            
            if (sundayFive) {
                [5, 10, 15].forEach(star => {
                    if (star < 30) {
                        Sp[star][0] = 1.0;
                        Sp[star][1] = 0.0;
                        Sp[star][2] = 0.0;
                    }
                });
            }
            
            return Sp;
        }
        
        function calcCost(L, s, sundayM, sundayFive, protect, mvpLevel, pcbang) {
            let base;
            if (s <= 9) {
                base = 1000 + (s + 1) * Math.pow(L, 3);
            } else {
                base = 1000 + Math.pow(s + 1, 2.7) * Math.pow(L, 3);
            }
            
            const divisors = {
                10: 571, 11: 314, 12: 214, 13: 157, 14: 107,
                15: 200, 16: 200, 17: 150, 18: 70, 19: 45,
                20: 200, 21: 125
            };
            const divisor = divisors[s] || (s >= 22 ? 200 : 36);
            let baseCost = base / divisor;
            
            if (sundayM) baseCost *= 0.7;
            
            let discount = 0.0;
            if (s >= 1 && s <= 17) {
                discount += MVP_DISCOUNTS[mvpLevel] || 0;
                discount += pcbang ? PCBANG_DISCOUNT : 0;
            }
            
            let discountedCost = baseCost * (1.0 - discount);
            
            if (protect && s >= 15 && s <= 17) {
                const originalBase = base / divisor;
                const protectCost = originalBase * 2;
                return discountedCost + protectCost;
            }
            
            return discountedCost;
        }
        
        function solveLinearSystem(A, b) {
            const n = A.length;
            const augmented = A.map((row, i) => [...row, b[i]]);
            
            for (let i = 0; i < n; i++) {
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                        maxRow = k;
                    }
                }
                [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];
                
                for (let k = i + 1; k < n; k++) {
                    const factor = augmented[k][i] / augmented[i][i];
                    for (let j = i; j <= n; j++) {
                        augmented[k][j] -= factor * augmented[i][j];
                    }
                }
            }
            
            const x = new Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = augmented[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= augmented[i][j] * x[j];
                }
                x[i] /= augmented[i][i];
            }
            
            return x;
        }
        
        function buildCostSystem(star, sundayOpO, Sp, L, sundayM, sundayFive, protect, mvpLevel, pcbang) {
            const n = star + 1;
            const A = Array(n).fill(0).map(() => Array(n).fill(0));
            const b = Array(n).fill(0);
            
            A[star][star] = 1;
            b[star] = 0;
            
            for (let s = 0; s < star; s++) {
                const idx = Math.min(s, 29);
                const [pSucc, pFail, pDestroy] = Sp[idx];
                const cost = calcCost(L, s, sundayM, sundayFive, protect, mvpLevel, pcbang);
                
                A[s][s] = 1 - pFail;
                const nextS = sundayOpO && s <= 10 ? Math.min(s + 2, star) : Math.min(s + 1, star);
                A[s][nextS] -= pSucc;
                
                if (pDestroy > 0 && star > 12) {
                    A[s][12] -= pDestroy;
                }
                
                b[s] = cost;
            }
            
            return [A, b];
        }
        
        function buildDestroySystem(star, sundayOpO, Sp) {
            const n = star + 1;
            const A = Array(n).fill(0).map(() => Array(n).fill(0));
            const b = Array(n).fill(0);
            
            A[star][star] = 1;
            b[star] = 0;
            
            for (let s = 0; s < star; s++) {
                const idx = Math.min(s, 29);
                const [pSucc, pFail, pDestroy] = Sp[idx];
                
                A[s][s] = 1 - pFail;
                const nextS = sundayOpO && s <= 10 ? Math.min(s + 2, star) : Math.min(s + 1, star);
                A[s][nextS] -= pSucc;
                
                if (pDestroy > 0 && star > 12) {
                    A[s][12] -= pDestroy;
                }
                
                b[s] = pDestroy;
            }
            
            return [A, b];
        }
        
        function buildCostSquaredSystem(star, sundayOpO, Sp, L, sundayM, sundayFive, protect, mvpLevel, pcbang, ECost) {
            const n = star + 1;
            const A = Array(n).fill(0).map(() => Array(n).fill(0));
            const b = Array(n).fill(0);
            
            A[star][star] = 1;
            b[star] = 0;
            
            for (let s = 0; s < star; s++) {
                const idx = Math.min(s, 29);
                const [pSucc, pFail, pDestroy] = Sp[idx];
                const cost = calcCost(L, s, sundayM, sundayFive, protect, mvpLevel, pcbang);
                
                A[s][s] = 1 - pFail;
                const nextS = sundayOpO && s <= 10 ? Math.min(s + 2, star) : Math.min(s + 1, star);
                A[s][nextS] -= pSucc;
                
                if (pDestroy > 0 && star > 12) {
                    A[s][12] -= pDestroy;
                }
                
                const rhs = cost * cost + 2 * cost * (ECost[s] - cost);
                b[s] = rhs;
            }
            
            return [A, b];
        }
        
        function buildDestroySquaredSystem(star, sundayOpO, Sp, EDestroy) {
            const n = star + 1;
            const A = Array(n).fill(0).map(() => Array(n).fill(0));
            const b = Array(n).fill(0);
            
            A[star][star] = 1;
            b[star] = 0;
            
            for (let s = 0; s < star; s++) {
                const idx = Math.min(s, 29);
                const [pSucc, pFail, pDestroy] = Sp[idx];
                
                A[s][s] = 1 - pFail;
                const nextS = sundayOpO && s <= 10 ? Math.min(s + 2, star) : Math.min(s + 1, star);
                A[s][nextS] -= pSucc;
                
                if (pDestroy > 0 && star > 12) {
                    A[s][12] -= pDestroy;
                }
                
                const rhs = pDestroy > 0 && star > 12 ? pDestroy * (1 + 2 * EDestroy[12]) : 0;
                b[s] = rhs;
            }
            
            return [A, b];
        }
        
        function buildCostDestroySystem(star, sundayOpO, Sp, L, sundayM, sundayFive, protect, mvpLevel, pcbang, ECost, EDestroy) {
            const n = star + 1;
            const A = Array(n).fill(0).map(() => Array(n).fill(0));
            const b = Array(n).fill(0);
            
            A[star][star] = 1;
            b[star] = 0;
            
            for (let s = 0; s < star; s++) {
                const idx = Math.min(s, 29);
                const [pSucc, pFail, pDestroy] = Sp[idx];
                const cost = calcCost(L, s, sundayM, sundayFive, protect, mvpLevel, pcbang);
                
                A[s][s] = 1 - pFail;
                const nextS = sundayOpO && s <= 10 ? Math.min(s + 2, star) : Math.min(s + 1, star);
                A[s][nextS] -= pSucc;
                
                if (pDestroy > 0 && star > 12) {
                    A[s][12] -= pDestroy;
                }
                
                const rhs = pDestroy > 0 && star > 12 ? pDestroy * (ECost[12] + cost + cost * EDestroy[12]) : 0;
                b[s] = rhs;
            }
            
            return [A, b];
        }
        
        function formatKoreanNumber(amount, decimal_places=3) {
            if (amount === 0) return "0";
            
            amount = Math.round(amount * Math.pow(10, decimal_places)) / Math.pow(10, decimal_places);
            
            const gyeong = Math.floor(amount / 1e16);
            const jo = Math.floor((amount % 1e16) / 1e12);
            const eok = Math.floor((amount % 1e12) / 1e8);
            const man = Math.floor((amount % 1e8) / 1e4);
            const remainder = amount % 1e4;
            
            const result = [];
            if (gyeong > 0) result.push(`${gyeong}경`);
            if (jo > 0) result.push(`${jo}조`);
            if (eok > 0) result.push(`${eok}억`);
            if (man > 0) result.push(`${man}만`);
            if (remainder > 0 || result.length === 0) {
                const formatted = remainder.toFixed(decimal_places).replace(/\.?0+$/, '');
                result.push(formatted);
            }
            
            return result.join(' ');
        }
        
        function formatNumber(num, decimals = 3) {
            if (num === 0) return "0";
            
            const absNum = Math.abs(num);
            
            if (absNum >= 10000) {
                return formatKoreanNumber(num, decimals);
            }
            
            return num.toLocaleString('ko-KR', {
                minimumFractionDigits: decimals,
                maximumFractionDigits: decimals
            });
        }
        
        function logGamma(z) {
            const coefficients = [
                76.18009172947146, -86.50532032941677,
                24.01409824083091, -1.231739572450155,
                0.1208650973866179e-2, -0.5395239384953e-5
            ];
            
            let y = z;
            let tmp = z + 5.5;
            tmp -= (z + 0.5) * Math.log(tmp);
            let ser = 1.000000000190015;
            
            for (let j = 0; j < 6; j++) {
                ser += coefficients[j] / ++y;
            }
            
            return -tmp + Math.log(2.5066282746310005 * ser / z);
        }
        
        function gammaFunction(alpha) {
            return Math.exp(logGamma(alpha));
        }
        
        function regularizedGammaP(a, x) {
            if (x < 0 || a <= 0) return 0;
            if (x === 0) return 0;
            if (x > a + 1) {
                return 1 - regularizedGammaQ(a, x);
            }
            
            let sum = 1 / a;
            let term = 1 / a;
            
            for (let n = 1; n < 500; n++) {
                term *= x / (a + n);
                sum += term;
                if (Math.abs(term) < Math.abs(sum) * 1e-15) break;
            }
            
            return Math.exp(-x + a * Math.log(x) - logGamma(a)) * sum;
        }
        
        function regularizedGammaQ(a, x) {
            if (x < 0 || a <= 0) return 1;
            if (x === 0) return 1;
            if (x < a + 1) {
                return 1 - regularizedGammaP(a, x);
            }
            
            let a0 = 1;
            let a1 = x;
            let b0 = 0;
            let b1 = 1;
            let fac = 1;
            
            for (let n = 1; n < 500; n++) {
                const an = n;
                const ana = an - a;
                a0 = (a1 + a0 * ana) * fac;
                b0 = (b1 + b0 * ana) * fac;
                const anf = an * fac;
                a1 = x * a0 + anf * a1;
                b1 = x * b0 + anf * b1;
                
                if (a1 !== 0) {
                    fac = 1 / a1;
                    const g = b1 * fac;
                    if (Math.abs((g - b0 / a0) / g) < 1e-15) {
                        return Math.exp(-x + a * Math.log(x) - logGamma(a)) * g;
                    }
                }
            }
            return 0;
        }
        
        function gammaCDF(x, alpha, beta) {
            if (x <= 0) return 0;
            const scaledX = x / beta;
            return regularizedGammaP(alpha, scaledX);
        }
        
        function gammaPPF(p, alpha, beta) {
            if (p <= 0) return 0;
            if (p >= 1) return Infinity;
            if (alpha <= 0 || beta <= 0) return NaN;
            
            let x;
            if (p < 0.5) {
                x = beta * Math.pow(-Math.log(1 - p) * gammaFunction(alpha), 1 / alpha);
            } else {
                const z = -1.0 + Math.sqrt(1.0 - 4.0 * (Math.log(1.0 - p) / (2.0 * alpha)));
                x = alpha * Math.pow(1.0 - 1.0 / (9.0 * alpha) + z / (3.0 * Math.sqrt(alpha)), 3);
                x = Math.max(x, 0.01) * beta;
            }
            
            for (let i = 0; i < 100; i++) {
                const cdf = gammaCDF(x, alpha, beta);
                const err = cdf - p;
                
                if (Math.abs(err) < 1e-12) break;
                
                const logPdf = (alpha - 1) * Math.log(x / beta) - x / beta - logGamma(alpha) - Math.log(beta);
                const pdf = Math.exp(logPdf);
                
                if (pdf > 1e-300 && isFinite(pdf)) {
                    const dpdf = pdf * ((alpha - 1) / x - 1 / beta);
                    const denom = 1 - 0.5 * err * dpdf / pdf;
                    const step = err / (pdf * denom);
                    
                    if (Math.abs(step) > x * 0.5) {
                        x = x - Math.sign(step) * x * 0.5;
                    } else {
                        x = x - step;
                    }
                    x = Math.max(x, 1e-10);
                } else {
                    if (err > 0) {
                        x *= 1.5;
                    } else {
                        x *= 0.5;
                    }
                }
                
                if (!isFinite(x) || x <= 0) {
                    x = alpha * beta;
                    break;
                }
            }
            
            return Math.max(0, x);
        }
        
        function calculate() {
            const star = parseInt(document.getElementById('targetStar').value);
            const fs = parseInt(document.getElementById('startStar').value);
            const L = parseInt(document.getElementById('itemLevel').value);
            
            const spareEok = parseFloat(document.getElementById('spareEok').value) || 0;
            const spareMan = parseFloat(document.getElementById('spareMan').value) || 0;
            const spare = spareEok * 1e8 + spareMan * 1e4;
            
            const mvpLevel = parseInt(document.getElementById('mvpLevel').value);
            
            const catch_ = document.getElementById('catch').checked;
            const sundayM = document.getElementById('sundayM').checked;
            const sundayD = document.getElementById('sundayD').checked;
            const protect = document.getElementById('protect').checked;
            const pcbang = document.getElementById('pcbang').checked;
            const sundayOpO = document.getElementById('sundayOpO').checked;
            const sundayFive = document.getElementById('sundayFive').checked;
            
            document.getElementById('loadingDiv').classList.remove('hidden');
            document.getElementById('resultsDiv').classList.add('hidden');
            document.getElementById('chartContainer').classList.add('hidden');
            
            setTimeout(() => {
                const Sp = initializeProbTable(catch_, sundayD, protect, sundayFive);
                
                const [ACost, bCost] = buildCostSystem(star, sundayOpO, Sp, L, sundayM, sundayFive, protect, mvpLevel, pcbang);
                const ECost = solveLinearSystem(ACost, bCost);
                
                const [ADestroy, bDestroy] = buildDestroySystem(star, sundayOpO, Sp);
                const EDestroy = solveLinearSystem(ADestroy, bDestroy);
                
                const meanCost = ECost[fs];
                const meanSpareCost = EDestroy[fs] * spare;
                const meanTotal = meanCost + meanSpareCost;
                
                let variance;
                if (spare === 0) {
                    const [ACostSq, bCostSq] = buildCostSquaredSystem(star, sundayOpO, Sp, L, sundayM, sundayFive, protect, mvpLevel, pcbang, ECost);
                    const ECostSq = solveLinearSystem(ACostSq, bCostSq);
                    variance = ECostSq[fs] - meanCost * meanCost;
                } else {
                    const [ACostSq, bCostSq] = buildCostSquaredSystem(star, sundayOpO, Sp, L, sundayM, sundayFive, protect, mvpLevel, pcbang, ECost);
                    const ECostSq = solveLinearSystem(ACostSq, bCostSq);
                    
                    const [ADestroySq, bDestroySq] = buildDestroySquaredSystem(star, sundayOpO, Sp, EDestroy);
                    const EDestroySq = solveLinearSystem(ADestroySq, bDestroySq);
                    
                    const [ACostDestroy, bCostDestroy] = buildCostDestroySystem(star, sundayOpO, Sp, L, sundayM, sundayFive, protect, mvpLevel, pcbang, ECost, EDestroy);
                    const ECostDestroy = solveLinearSystem(ACostDestroy, bCostDestroy);
                    
                    const varCost = ECostSq[fs] - meanCost * meanCost;
                    const varDestroy = EDestroySq[fs] - EDestroy[fs] * EDestroy[fs];
                    const covCostDestroy = ECostDestroy[fs] - meanCost * EDestroy[fs];
                    
                    variance = varCost + spare * spare * varDestroy + 2 * spare * covCostDestroy;
                }
                
                variance = Math.max(0, variance);
                const std = Math.sqrt(variance);
                
                const alpha = variance > 0 ? (meanTotal * meanTotal / variance) : 1;
                const beta = variance > 0 ? (variance / meanTotal) : meanTotal;
                
                currentAlpha = alpha;
                currentBeta = beta;
                
                displayResults(meanTotal, std, meanCost, meanSpareCost, EDestroy[fs], alpha, beta);
                
                document.getElementById('loadingDiv').classList.add('hidden');
            }, 100);
        }
        
        function displayResults(mean, std, costRaw, spareCost, destroys, alpha, beta) {
            const resultsDiv = document.getElementById('resultsDiv');
            const resultsContent = document.getElementById('resultsContent');
            
            let html = `
                <div class="result-item">
                    <span class="result-label">평균 총 비용 (μ):</span>
                    <span class="result-value">${formatKoreanNumber(mean)} 메소</span>
                </div>
                <div class="result-item">
                    <span class="result-label">└ 강화 비용:</span>
                    <span class="result-value">${formatKoreanNumber(costRaw)} 메소</span>
                </div>
                <div class="result-item">
                    <span class="result-label">└ 스페어 비용:</span>
                    <span class="result-value">${formatKoreanNumber(spareCost)} 메소</span>
                </div>
                <div class="result-item">
                    <span class="result-label">표준편차 (σ):</span>
                    <span class="result-value">${formatKoreanNumber(std)} 메소 (${(std/mean*100).toFixed(2)}%)</span>
                </div>
                <div class="result-item">
                    <span class="result-label">평균 파괴 횟수:</span>
                    <span class="result-value">${formatNumber(destroys, 3)}회</span>
                </div>
            `;
            
            resultsContent.innerHTML = html;
            resultsDiv.classList.remove('hidden');
            
            drawChart(mean, std, alpha, beta);
        }
        
        function drawChart(mean, std, alpha, beta) {
            const canvas = document.getElementById('distributionChart');
            const ctx = canvas.getContext('2d');
            
            if (window.chartInstance) {
                window.chartInstance.destroy();
            }
            
            const xMin = Math.max(0, mean - 3 * std);
            const xMax = mean + 4 * std;
            const points = 300;
            const step = (xMax - xMin) / points;
            
            const labels = [];
            const pdfData = [];
            const cdfData = [];
            
            for (let i = 0; i <= points; i++) {
                const x = xMin + i * step;
                labels.push(x);
                
                const logPdf = (alpha - 1) * Math.log(x / beta) - x / beta - logGamma(alpha) - Math.log(beta);
                const pdf = Math.exp(logPdf);
                pdfData.push(pdf);
                
                const cdf = gammaCDF(x, alpha, beta);
                cdfData.push(cdf);
            }
            
            const mode = alpha > 1 ? (alpha - 1) * beta : 0;
            
            window.chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: '확률 밀도 (PDF)',
                            data: pdfData,
                            borderColor: 'rgb(102, 126, 234)',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2,
                            yAxisID: 'y'
                        },
                        {
                            label: '누적 확률 (CDF)',
                            data: cdfData,
                            borderColor: 'rgb(118, 75, 162)',
                            backgroundColor: 'rgba(118, 75, 162, 0.1)',
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2,
                            borderDash: [5, 5],
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: '비용 분포 (감마 분포)',
                            font: { size: 18, weight: 'bold' },
                            color: '#667eea'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return '비용: ' + formatKoreanNumber(context[0].parsed.x) + ' 메소';
                                },
                                label: function(context) {
                                    if (context.dataset.label === '확률 밀도 (PDF)') {
                                        return 'PDF: ' + context.parsed.y.toExponential(4);
                                    } else {
                                        return 'CDF: ' + (context.parsed.y * 100).toFixed(2) + '%';
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: '총 비용 (메소)',
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                callback: function(value) {
                                    return formatKoreanNumber(value);
                                },
                                maxRotation: 45,
                                minRotation: 45
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: '확률 밀도',
                                font: { size: 14, weight: 'bold' },
                                color: 'rgb(102, 126, 234)'
                            },
                            ticks: {
                                color: 'rgb(102, 126, 234)',
                                callback: function(value) {
                                    if (value === 0) return '0';
                                    const exp = Math.floor(Math.log10(Math.abs(value)));
                                    if (exp < -2 || exp > 3) {
                                        const mantissa = (value / Math.pow(10, exp)).toFixed(2);
                                        return mantissa + 'E' + exp;
                                    }
                                    return value.toFixed(4);
                                }
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: '누적 확률',
                                font: { size: 14, weight: 'bold' },
                                color: 'rgb(118, 75, 162)'
                            },
                            ticks: {
                                color: 'rgb(118, 75, 162)',
                                callback: function(value) {
                                    return (value * 100).toFixed(0) + '%';
                                }
                            },
                            min: 0,
                            max: 1,
                            grid: {
                                drawOnChartArea: false
                            }
                        }
                    }
                }
            });
            
            document.getElementById('chartContainer').classList.remove('hidden');
        }
        
        function calculateCustomPercentile() {
            const percentileInput = document.getElementById('customPercentile').value;
            const percentile = parseFloat(percentileInput);
            
            if (isNaN(percentile) || percentile < 0 || percentile > 100) {
                document.getElementById('customPercentileResult').innerHTML = '⚠️ 0에서 100 사이의 값을 입력해주세요.';
                document.getElementById('customPercentileResult').classList.remove('hidden');
                return;
            }
            
            if (!currentAlpha || !currentBeta) {
                document.getElementById('customPercentileResult').innerHTML = '⚠️ 먼저 계산하기 버튼을 눌러주세요.';
                document.getElementById('customPercentileResult').classList.remove('hidden');
                return;
            }
            
            const p = percentile / 100;
            const cost = gammaPPF(p, currentAlpha, currentBeta);
            
            document.getElementById('customPercentileResult').innerHTML = 
                `${percentile}% 달성 예상 비용: <span style="color: #764ba2;">${formatKoreanNumber(cost)} 메소</span>`;
            document.getElementById('customPercentileResult').classList.remove('hidden');
        }
        
        function calculateCostPercentile() {
            const costGyeong = parseFloat(document.getElementById('costGyeong').value) || 0;
            const costJo = parseFloat(document.getElementById('costJo').value) || 0;
            const costEok = parseFloat(document.getElementById('costEok').value) || 0;
            const costMan = parseFloat(document.getElementById('costMan').value) || 0;
            const costWon = parseFloat(document.getElementById('costWon').value) || 0;
            
            const totalCost = costGyeong * 1e16 + costJo * 1e12 + costEok * 1e8 + costMan * 1e4 + costWon;
            
            if (totalCost <= 0) {
                document.getElementById('costPercentileResult').innerHTML = '⚠️ 비용을 입력해주세요.';
                document.getElementById('costPercentileResult').classList.remove('hidden');
                return;
            }
            
            if (!currentAlpha || !currentBeta) {
                document.getElementById('costPercentileResult').innerHTML = '⚠️ 먼저 계산하기 버튼을 눌러주세요.';
                document.getElementById('costPercentileResult').classList.remove('hidden');
                return;
            }
            
            const cdf = gammaCDF(totalCost, currentAlpha, currentBeta);
            const percentile = cdf * 100;
            
            document.getElementById('costPercentileResult').innerHTML = 
                `<span style="color: #764ba2;">${formatKoreanNumber(totalCost)} 메소</span>는 약 <span style="color: #764ba2;">${percentile.toFixed(2)}%</span> 분위수입니다.<br>` +
                `<span style="font-size: 0.9em; color: #6c757d;">→ ${percentile.toFixed(2)}%의 경우가 이 비용 이하로 달성됩니다.</span>`;
            document.getElementById('costPercentileResult').classList.remove('hidden');
        }
    </script>
</body>
</html>
